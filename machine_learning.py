# -*- coding: utf-8 -*-
"""machine learning.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1T_B0-YpMj6W2ELBtthMtGFbeA0XUy9FX

# Importando bibliotecas necessárias

# Instalação das bibliotecas matplotlib e scikit-learn
!pip install -q matplotlib
!pip install -q scikit-learn

import pandas as pd
import numpy as np
from matplotlib import pyplot as plt
from sklearn.datasets import load_iris

# Carregando o conjunto de dados Iris
data = load_iris()
iris = pd.DataFrame(data['data'], columns=data.feature_names)
target = data.target
print(iris)

# Importando o algoritmo de SVM
from sklearn.model_selection import cross_val_score
from sklearn.svm import SVC
svc = SVC(gamma="auto")

# Testando o modelo 'svc' na nossa base 'iris' usando validação cruzada
cv_result = cross_val_score(svc, iris, target, cv=10, scoring='accuracy')

# Calculando a acurácia média em porcentagem do nosso modelo
print('Acurácia com cross-validation:', cv_result.mean() * 100)

# Treinando o modelo SVC com os dados Iris
svc.fit(iris, target)

# Fazendo uma previsão para uma amostra específica
predicted_class = svc.predict([[6.9, 2.8, 6.1, 2.3]])
print('Classe prevista para a amostra:', predicted_class)

# Visualização dos dados Iris

# Scatter plot das características 'sepal length (cm)' e 'petal width (cm)' colorido por classe
plt.scatter(iris['sepal length (cm)'], iris['petal width (cm)'], c=target)
plt.title('Iris')

# Criação de um grid para plotar as regiões de decisão do modelo
x0_min, x0_max = iris['sepal length (cm)'].min(), iris['sepal length (cm)'].max()
x1_min, x1_max = iris['petal width (cm)'].min(), iris['petal width (cm)'].max()
w = x0_max - x0_min
h = x1_max - x1_min
x0, x1 = np.meshgrid(np.linspace(x0_min - 0.1 * w, x0_max + 0.1 * w, 300), np.linspace(x1_min - 0.1 * h, x1_max + 0.1 * h, 300))

# Treinando o modelo SVM apenas com as características 'sepal length (cm)' e 'petal width (cm)'
svc.fit(iris[['sepal length (cm)', 'petal width (cm)']], target)

# Fazendo previsões para o grid
ypred = svc.predict(np.c_[x0.reshape(-1, 1), x1.reshape(-1, 1)])
ypred = ypred.reshape(x0.shape)

# Plotando as regiões de decisão e os pontos de dados coloridos por classe
plt.contourf(x0, x1, ypred)
plt.scatter(iris['sepal length (cm)'], iris['petal width (cm)'], c=target, s=64, edgecolors='k')
plt.title('Iris')
plt.show()
